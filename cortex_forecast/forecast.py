# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_cortex_forecast.ipynb.

# %% auto 0
__all__ = ['SnowflakeMLForecast']

# %% ../nbs/01_cortex_forecast.ipynb 4
import yaml
import random
import string
import streamlit as st
import logging

from datetime import datetime
from .connection import SnowparkConnection


logging.getLogger('snowflake.snowpark').setLevel(logging.WARNING)
 

# %% ../nbs/01_cortex_forecast.ipynb 5
class SnowflakeMLForecast(SnowparkConnection):
    def __init__(self, config_file, connection_config=None):
        super().__init__(connection_config=connection_config)
        with open(config_file, 'r') as file:
            self.config = yaml.safe_load(file)
        self.model_name = self._generate_unique_model_name()

    def _generate_unique_model_name(self):
        suffix = ''.join(random.choices(string.ascii_lowercase, k=5))
        timestamp = datetime.now().strftime("%Y%m%d")
        return f"{self.config['model']['name']}_{timestamp}_{suffix}"

    def _generate_input_data_sql(self):
        table = self.config['input_data']['table']
        timestamp_col = self.config['input_data']['timestamp_column']
        target_col = self.config['input_data']['target_column']
        exogenous_cols = self.config['input_data'].get('exogenous_columns') or []
        
        training_days = self.config['forecast_config']['training_days']

        columns = [f"TO_TIMESTAMP_NTZ({timestamp_col}) AS {timestamp_col}",
                f"{target_col} AS target"]
        columns.extend(exogenous_cols)

        sql = f"""
        CREATE OR REPLACE TRANSIENT TABLE {self.model_name}_train AS
        SELECT {', '.join(columns)}
        FROM {table}
        WHERE TO_TIMESTAMP_NTZ({timestamp_col}) < DATEADD(day, -{training_days}, CURRENT_DATE())
        """
        return sql

    def _generate_create_model_sql(self):
        # Use the table name from the config file for the training data
        input_data = f"SYSTEM$REFERENCE('table', '{self.config['input_data']['table']}')"
        timestamp_col = self.config['input_data']['timestamp_column']
        target_col = self.config['input_data']['target_column']
        series_col = self.config['input_data'].get('series_column')
        config_object = self.config['forecast_config'].get('config_object', {})
        
        # Start building the SQL
        sql = f"""
        CREATE OR REPLACE SNOWFLAKE.ML.FORECAST {self.model_name}(
            INPUT_DATA => {input_data},
            TIMESTAMP_COLNAME => '{timestamp_col}',
            TARGET_COLNAME => '{target_col}',
        """
        
        # Add optional series column; use NULL if series_col is None
        if series_col:
            sql += f"SERIES_COLNAME => '{series_col}',"
        
        # Construct the CONFIG_OBJECT using OBJECT_CONSTRUCT
        config_sql = "OBJECT_CONSTRUCT("
        for key, value in config_object.items():
            if isinstance(value, dict):
                nested_config = "OBJECT_CONSTRUCT("
                nested_config += ", ".join([f"'{k}', {self._format_value(v)}" for k, v in value.items()])
                nested_config += ")"
                config_sql += f"'{key}', {nested_config}, "
            else:
                config_sql += f"'{key}', {self._format_value(value)}, "
        config_sql = config_sql.rstrip(", ") + ")"
        
        sql += f"CONFIG_OBJECT => {config_sql},"
        
        sql = sql.rstrip(',')  # Clean up trailing commas
        sql += ")"
        
        # Handle optional TAG and COMMENT
        tags = self.config['model'].get('tags')
        comment = self.config['model'].get('comment')
        
        if tags:
            tag_str = ", ".join([f"{k} = '{v}'" for k, v in tags.items()])
            sql += f" WITH TAG ({tag_str})"
        
        if comment:
            sql += f" COMMENT = '{comment}'"
        
        sql += ";"

        # Debug prints
        print("Generated SQL:")
        print(sql)
        
        return sql

    def create_tags(self):
        """
        Create the necessary tags in Snowflake before running the forecast creation.
        """
        tags = self.config['model'].get('tags')
        if not tags:
            return  # No tags to create

        for tag_name, tag_comment in tags.items():
            # TODO: Check if tag already exists
            create_tag_sql = f"CREATE OR REPLACE TAG {tag_name} COMMENT = 'Specifies the {tag_comment.lower()}';"
            print(f"Creating tag: {create_tag_sql}")
            st.write(f"Creating tag: {create_tag_sql}")
            self.run_command(create_tag_sql)

    def _format_value(self, value):
        """
        Helper function to format values for SQL. Converts Python None to SQL NULL,
        and ensures strings are correctly quoted.
        """
        if value is None:
            return "NULL"
        elif isinstance(value, bool):
            return "TRUE" if value else "FALSE"
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, str):
            return f"'{value}'"
        return str(value)


    def _generate_forecast_sql(self):
        try:
            forecast_days = self.config['forecast_config']['forecast_days']
            output_table = self.config['output']['table']
            
            # Extract the evaluation config from the nested config_object
            config_object = self.config['forecast_config'].get('config_object', {})
            evaluation_config = config_object.get('evaluation_config', {})

            print("Configuration Details:")
            print(f"Forecast Days: {forecast_days}")
            print(f"Output Table: {output_table}")
            print(f"Evaluation Config: {evaluation_config}")

            # Ensure 'prediction_interval' is present in evaluation_config
            prediction_interval = evaluation_config.get('prediction_interval', 0.95)  # Default to 0.95 if not provided

            sql = f"""
            CREATE OR REPLACE TABLE {output_table} AS
            SELECT
                ts AS forecast_date,
                forecast,
                lower_bound,
                upper_bound
            FROM
                TABLE({self.model_name}!FORECAST(
                    FORECASTING_PERIODS => {forecast_days},
                    CONFIG_OBJECT => {{'prediction_interval': {prediction_interval}}}
                ));
            """
            print("Generated Forecast SQL:")
            print(sql)
            return sql
        except KeyError as e:
            print(f"KeyError encountered: {e}")
            raise e

    def run_query(self, query):
        """
        Execute a query and return the result as a Pandas DataFrame.
        """
        df = self.session.sql(query).to_pandas() if self.session else None
        return df

    def run_command(self, query):
        """
        Execute a command and return the result.
        """
        result = self.session.sql(query).collect() if self.session else None
        return result

    def create_and_run_forecast(self):
        self.create_tags()

        print("Step 1/4: Creating training table...")
        self.run_command(self._generate_input_data_sql())

        print("Step 2/4: Creating forecast model...")
        self.run_command(self._generate_create_model_sql())

        print("Step 3/4: Generating forecasts...")
        self.run_command(self._generate_forecast_sql())

        print("Step 4/4: Fetching forecast results...")
        forecast_data = self.run_query(f"SELECT * FROM {self.config['output']['table']} ORDER BY forecast_date")

        return forecast_data

    def cleanup(self):
        print("Cleaning up temporary tables and models...")
        cleanup_commands = f"""
        DROP TABLE IF EXISTS {self.model_name}_train;
        DROP TABLE IF EXISTS {self.config['output']['table']};
        DROP MODEL IF EXISTS {self.model_name};
        """

        for command in cleanup_commands.split(';'):
            if command.strip():
                self.run_command(command)
